import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, classification_report
import pickle
import os

class VulnerabilityClassifier:
    """
    A classifier for vulnerability severity using scikit-learn
    """
    
    def __init__(self, model_type='random_forest'):
        """
        Initialize the classifier
        
        Args:
            model_type (str): Type of model to use ('random_forest' or 'logistic_regression')
        """
        self.vectorizer = TfidfVectorizer(max_features=1000)
        
        if model_type == 'random_forest':
            self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        elif model_type == 'logistic_regression':
            self.model = LogisticRegression(max_iter=1000, random_state=42)
        else:
            raise ValueError(f"Unsupported model type: {model_type}")
        
        self.model_type = model_type
        self.is_trained = False
        self.metrics = {}
    
    def preprocess_data(self, X, y=None):
        """
        Preprocess the data for training or prediction
        
        Args:
            X (list): List of text descriptions
            y (list, optional): List of labels
        
        Returns:
            tuple: (X_processed, y) or X_processed if y is None
        """
        # Convert to DataFrame if not already
        if isinstance(X, list):
            X = pd.DataFrame({'description': X})
        
        # Handle missing values
        X = X.fillna('')
        
        # Extract relevant features
        if 'description' in X.columns:
            descriptions = X['description'].astype(str).tolist()
        elif 'title' in X.columns and 'description' in X.columns:
            descriptions = (X['title'] + ' ' + X['description']).astype(str).tolist()
        else:
            descriptions = X.iloc[:, 0].astype(str).tolist()
        
        # Transform text data
        if self.is_trained:
            X_processed = self.vectorizer.transform(descriptions)
        else:
            X_processed = self.vectorizer.fit_transform(descriptions)
        
        if y is not None:
            return X_processed, y
        else:
            return X_processed
    
    def train(self, X_train, y_train, validation_split=0.2):
        """
        Train the classifier
        
        Args:
            X_train (list): List of text descriptions
            y_train (list): List of labels
            validation_split (float): Proportion of data to use for validation
        
        Returns:
            dict: Metrics from training
        """
        # Preprocess the data
        X_processed, y_train = self.preprocess_data(X_train, y_train)
        
        # Split into training and validation sets
        X_train_split, X_val, y_train_split, y_val = train_test_split(
            X_processed, y_train, test_size=validation_split, random_state=42
        )
        
        # Train the model
        self.model.fit(X_train_split, y_train_split)
        
        # Make predictions on validation set
        y_pred = self.model.predict(X_val)
        
        # Calculate metrics
        self.metrics = {
            'accuracy': accuracy_score(y_val, y_pred),
            'precision': precision_score(y_val, y_pred, average='weighted'),
            'recall': recall_score(y_val, y_pred, average='weighted'),
            'f1': f1_score(y_val, y_pred, average='weighted')
        }
        
        # Set trained flag
        self.is_trained = True
        
        return self.metrics
    
    def predict(self, X):
        """
        Predict severity for new vulnerabilities
        
        Args:
            X (list): List of text descriptions
        
        Returns:
            list: Predicted severity levels
        """
        if not self.is_trained:
            raise ValueError("Model has not been trained yet")
        
        # Preprocess the data
        X_processed = self.preprocess_data(X)
        
        # Make predictions
        predictions = self.model.predict(X_processed)
        
        return predictions
    
    def predict_proba(self, X):
        """
        Predict severity probabilities for new vulnerabilities
        
        Args:
            X (list): List of text descriptions
        
        Returns:
            array: Predicted probabilities for each class
        """
        if not self.is_trained:
            raise ValueError("Model has not been trained yet")
        
        # Preprocess the data
        X_processed = self.preprocess_data(X)
        
        # Make probability predictions
        probabilities = self.model.predict_proba(X_processed)
        
        return probabilities
    
    def save_model(self, path='vulnerability_classifier.pkl'):
        """
        Save the trained model to disk
        
        Args:
            path (str): Path to save the model
        """
        if not self.is_trained:
            raise ValueError("Model has not been trained yet")
        
        model_data = {
            'vectorizer': self.vectorizer,
            'model': self.model,
            'model_type': self.model_type,
            'metrics': self.metrics
        }
        
        with open(path, 'wb') as f:
            pickle.dump(model_data, f)
    
    @classmethod
    def load_model(cls, path='vulnerability_classifier.pkl'):
        """
        Load a trained model from disk
        
        Args:
            path (str): Path to the saved model
        
        Returns:
            VulnerabilityClassifier: Loaded classifier
        """
        with open(path, 'rb') as f:
            model_data = pickle.load(f)
        
        classifier = cls(model_type=model_data['model_type'])
        classifier.vectorizer = model_data['vectorizer']
        classifier.model = model_data['model']
        classifier.metrics = model_data['metrics']
        classifier.is_trained = True
        
        return classifier
